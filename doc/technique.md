# 技术细节

## 验证码OCR
如果不能自动识别验证码，那就无法实现自动登录，也就无法实现自动化健康申报。其实，cas 系统的验证码非常简单，它具有如下特点：

1) 干扰线固定两条，而且还在有效字符的下层
2) 字符非常标准，不扭曲、不旋转、不缩放、不……什么都不

针对第1点，由于干扰线不会覆盖掉有效字符，因此可以用简单的逐像素做 RGB 检测的方式，来判断当前这个像素是否属于有效字符的一部分。接着，用 BFS（取8连通块作为自己的邻接点）分割图像，再把像素数过小的连通块去掉，就能把有效字符抠出来了。

针对第2点，由于字符非常之标准，因此对于抠出来的每一个有效字符，都做一个非常简单的特征提取即可。这里使用的特征是：把抠出来后的每一个有效字符看作一个01矩阵，将这个矩阵分成田字格的4部分，取每一部分1的数目作为特征，因此只有4维。经过简单的训练之后，即可相对准确地识别字符了。

做过一个简单的成功率统计，模拟登录了100次cas系统，这100张验证码中，94张被成功去噪+分割（即第一步），在这94张中有90张识别正确（即第二步），总体来看识别率在90%左右。

## 模拟登录
这个是用常规的爬虫技术实现的，大学的 cas 系统没有做反爬处理，相对比较好弄。需要注意的是，跟 cas 系统交互时，有一些简单的安全机制。登录成功后，会返回一个叫 `TGC` 的登录态 cookie，这个 `TGC` 是跟 HTTP 请求的 header 相关联的。因此，如果不伪造 header 直接去模拟登录，虽然可以登录 cas 系统成功，但是拿到的 `TGC` 是不能用来登录无头浏览器 jksb 系统的，因为 UA 信息以及其他各种 header 字段不一致，被大学的服务器认定为不妥，就不会给你登录的。

为什么既然都用无头浏览器了，不直接在浏览器里面模拟登录呢？因为是先写好了发包模拟登录的代码，不用感觉可惜，其次是也用过无头浏览器模拟登录，感觉这有些影响效率，因为要渲染登录页面。

## 无头浏览器
无头浏览器用来处理 jksb 系统，因为 jksb 系统出乎意料地做了相对很强的反爬措施。有一个 Cookie 不是通过 response header 的 `Set-Cookie` 字段传给客户端的，而是用了混淆过的 JS 脚本在前端生成的，而且会动态改变，强行做逆向分析太难、太耗时了，希望有高手可以指教一下。

除此以外，jksb 系统还有无头浏览器的检测，需要让无头浏览器预先执行一段 [JS 脚本](/internal/pkg/jksb/bypass.js)才可以伪装成正常的浏览器，这一部分可以看这几个网站：

- [It is *not* possible to detect and block Chrome headless](https://intoli.com/blog/not-possible-to-block-chrome-headless/)
- [Making Chrome Headless Undetectable](https://intoli.com/blog/making-chrome-headless-undetectable/)

## 其他
其他就是一些常规的互联网业务了。
